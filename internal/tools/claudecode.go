package tools

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

// ClaudeCodeTool wraps the Claude Code CLI for codebase analysis and fix generation.
type ClaudeCodeTool struct {
	workDir         string
	maxRetries      int
	timeout         time.Duration
	anthropicAPIKey string
}

// NewClaudeCodeTool creates a new Claude Code tool.
func NewClaudeCodeTool(workDir, anthropicAPIKey string) *ClaudeCodeTool {
	return &ClaudeCodeTool{
		workDir:         workDir,
		maxRetries:      2,
		timeout:         10 * time.Minute,
		anthropicAPIKey: anthropicAPIKey,
	}
}

// FixRequest contains the error information for Claude Code to analyze.
type FixRequest struct {
	IssueID      string  `json:"issue_id"`
	Title        string  `json:"title"`
	ErrorType    string  `json:"error_type"`
	ErrorMessage string  `json:"error_message"`
	Level        string  `json:"level"`
	Platform     string  `json:"platform"`
	Culprit      string  `json:"culprit"`
	Stacktrace   []Frame `json:"stacktrace"`
	Permalink    string  `json:"permalink"`
}

// Frame represents a stacktrace frame.
type Frame struct {
	Filename string `json:"filename"`
	Function string `json:"function"`
	LineNo   int    `json:"line_no"`
	ColNo    int    `json:"col_no"`
	InApp    bool   `json:"in_app"`
	Module   string `json:"module,omitempty"`
}

// FixResponse contains the fix generated by Claude Code.
type FixResponse struct {
	Success     bool         `json:"success"`
	Description string       `json:"description"`
	Files       []FileChange `json:"files"`
	PRTitle     string       `json:"pr_title"`
	PRBody      string       `json:"pr_body"`
	Error       string       `json:"error,omitempty"`
}

// FileChange represents a file modification.
type FileChange struct {
	Path       string `json:"path"`
	Content    string `json:"content"`
	ChangeType string `json:"change_type"` // "modify", "create", "delete"
}

// GenerateFix uses Claude Code to analyze the error and generate a fix.
func (c *ClaudeCodeTool) GenerateFix(ctx context.Context, req *FixRequest) (*FixResponse, error) {
	// Build the prompt for Claude Code
	prompt := c.buildPrompt(req)

	// Create a temporary file for the output format instructions
	outputInstructions := `
After analyzing and fixing the error, output your changes in the following JSON format (and nothing else after the JSON):

` + "```json" + `
{
  "success": true,
  "description": "Brief description of what was fixed",
  "files": [
    {
      "path": "relative/path/to/file.go",
      "content": "complete new file content",
      "change_type": "modify"
    }
  ],
  "pr_title": "fix: Concise title for the PR",
  "pr_body": "## Summary\n\nDescription of the fix\n\n## Changes\n\n- List of changes\n\n## Root Cause\n\nExplanation of what caused the issue"
}
` + "```" + `

If you cannot fix the issue, output:
` + "```json" + `
{
  "success": false,
  "error": "Explanation of why the fix couldn't be generated"
}
` + "```"

	fullPrompt := prompt + "\n\n" + outputInstructions

	// Run Claude Code
	output, err := c.runClaudeCode(ctx, fullPrompt)
	if err != nil {
		return &FixResponse{
			Success: false,
			Error:   fmt.Sprintf("Claude Code execution failed: %v", err),
		}, nil
	}

	// Parse the response
	return c.parseResponse(output)
}

// buildPrompt constructs the prompt for Claude Code.
func (c *ClaudeCodeTool) buildPrompt(req *FixRequest) string {
	var sb strings.Builder

	sb.WriteString("I need you to analyze and fix a production error. Here are the details:\n\n")

	sb.WriteString(fmt.Sprintf("## Error Information\n"))
	sb.WriteString(fmt.Sprintf("- **Issue ID**: %s\n", req.IssueID))
	sb.WriteString(fmt.Sprintf("- **Title**: %s\n", req.Title))
	sb.WriteString(fmt.Sprintf("- **Error Type**: %s\n", req.ErrorType))
	sb.WriteString(fmt.Sprintf("- **Error Message**: %s\n", req.ErrorMessage))
	sb.WriteString(fmt.Sprintf("- **Severity**: %s\n", req.Level))
	sb.WriteString(fmt.Sprintf("- **Platform**: %s\n", req.Platform))
	sb.WriteString(fmt.Sprintf("- **Culprit**: %s\n", req.Culprit))

	if req.Permalink != "" {
		sb.WriteString(fmt.Sprintf("- **Sentry Link**: %s\n", req.Permalink))
	}

	if len(req.Stacktrace) > 0 {
		sb.WriteString("\n## Stacktrace\n")
		for i, frame := range req.Stacktrace {
			inApp := ""
			if frame.InApp {
				inApp = " [IN APP]"
			}
			sb.WriteString(fmt.Sprintf("%d. `%s:%d` in `%s`%s\n",
				i+1, frame.Filename, frame.LineNo, frame.Function, inApp))
		}
	}

	sb.WriteString("\n## Instructions\n")
	sb.WriteString("1. Explore the codebase to understand the context around this error\n")
	sb.WriteString("2. Focus on files marked [IN APP] in the stacktrace\n")
	sb.WriteString("3. Identify the root cause of the error\n")
	sb.WriteString("4. Implement a fix that:\n")
	sb.WriteString("   - Addresses the root cause (not just symptoms)\n")
	sb.WriteString("   - Follows existing code patterns and style\n")
	sb.WriteString("   - Includes appropriate error handling\n")
	sb.WriteString("   - Is minimal and focused\n")
	sb.WriteString("5. Provide complete file contents for any modified files\n")

	return sb.String()
}

// runClaudeCode executes the Claude Code CLI.
func (c *ClaudeCodeTool) runClaudeCode(ctx context.Context, prompt string) (string, error) {
	ctx, cancel := context.WithTimeout(ctx, c.timeout)
	defer cancel()

	// Write prompt to a temp file to avoid shell escaping issues
	promptFile, err := os.CreateTemp("", "claude-prompt-*.txt")
	if err != nil {
		return "", fmt.Errorf("failed to create prompt file: %w", err)
	}
	defer os.Remove(promptFile.Name())

	if _, err := promptFile.WriteString(prompt); err != nil {
		return "", fmt.Errorf("failed to write prompt: %w", err)
	}
	promptFile.Close()

	// Build the claude command
	// Using --print flag for non-interactive output
	cmd := exec.CommandContext(ctx, "claude",
		"--print",                        // Print response and exit
		"--dangerously-skip-permissions", // Allow file operations without prompts
	)

	// Set working directory to the repo
	cmd.Dir = c.workDir

	// Set up environment with API key if provided
	cmd.Env = os.Environ()
	if c.anthropicAPIKey != "" {
		cmd.Env = append(cmd.Env, "ANTHROPIC_API_KEY="+c.anthropicAPIKey)
	}

	// Pipe the prompt via stdin
	promptContent, _ := os.ReadFile(promptFile.Name())
	cmd.Stdin = bytes.NewReader(promptContent)

	// Capture output
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	// Run the command
	err = cmd.Run()
	if err != nil {
		// Check if it's a timeout
		if ctx.Err() == context.DeadlineExceeded {
			return "", fmt.Errorf("Claude Code timed out after %v", c.timeout)
		}
		return "", fmt.Errorf("Claude Code failed: %v\nstderr: %s", err, stderr.String())
	}

	return stdout.String(), nil
}

// parseResponse extracts the JSON fix response from Claude Code output.
func (c *ClaudeCodeTool) parseResponse(output string) (*FixResponse, error) {
	// Find JSON block in the output
	jsonStr := extractJSON(output)
	if jsonStr == "" {
		return &FixResponse{
			Success: false,
			Error:   "No valid JSON response found in Claude Code output",
		}, nil
	}

	var resp FixResponse
	if err := json.Unmarshal([]byte(jsonStr), &resp); err != nil {
		return &FixResponse{
			Success: false,
			Error:   fmt.Sprintf("Failed to parse JSON response: %v", err),
		}, nil
	}

	return &resp, nil
}

// extractJSON finds and extracts JSON from text that may contain markdown.
func extractJSON(text string) string {
	// Try to find JSON in code blocks first
	if idx := strings.Index(text, "```json"); idx != -1 {
		start := idx + 7
		end := strings.Index(text[start:], "```")
		if end != -1 {
			return strings.TrimSpace(text[start : start+end])
		}
	}

	// Try plain code blocks
	if idx := strings.Index(text, "```"); idx != -1 {
		start := idx + 3
		// Skip language identifier if present
		if newline := strings.Index(text[start:], "\n"); newline != -1 {
			start += newline + 1
		}
		end := strings.Index(text[start:], "```")
		if end != -1 {
			candidate := strings.TrimSpace(text[start : start+end])
			if strings.HasPrefix(candidate, "{") {
				return candidate
			}
		}
	}

	// Try to find raw JSON object
	start := strings.Index(text, "{")
	if start == -1 {
		return ""
	}

	// Find matching closing brace
	depth := 0
	inString := false
	escaped := false

	for i := start; i < len(text); i++ {
		ch := text[i]

		if escaped {
			escaped = false
			continue
		}

		if ch == '\\' && inString {
			escaped = true
			continue
		}

		if ch == '"' {
			inString = !inString
			continue
		}

		if inString {
			continue
		}

		if ch == '{' {
			depth++
		} else if ch == '}' {
			depth--
			if depth == 0 {
				return text[start : i+1]
			}
		}
	}

	return ""
}

// CloneRepo clones a git repository to a temporary directory.
func CloneRepo(ctx context.Context, repoURL, token string) (string, func(), error) {
	// Create temp directory
	tmpDir, err := os.MkdirTemp("", "sentryagent-repo-*")
	if err != nil {
		return "", nil, fmt.Errorf("failed to create temp dir: %w", err)
	}

	cleanup := func() {
		os.RemoveAll(tmpDir)
	}

	// Build authenticated URL if token provided
	authURL := repoURL
	if token != "" && strings.HasPrefix(repoURL, "https://github.com/") {
		// Insert token into URL: https://TOKEN@github.com/...
		authURL = strings.Replace(repoURL, "https://github.com/",
			fmt.Sprintf("https://%s@github.com/", token), 1)
	}

	// Clone the repository
	cmd := exec.CommandContext(ctx, "git", "clone", "--depth", "1", authURL, tmpDir)
	cmd.Env = append(os.Environ(), "GIT_TERMINAL_PROMPT=0")

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		cleanup()
		return "", nil, fmt.Errorf("git clone failed: %v\n%s", err, stderr.String())
	}

	return tmpDir, cleanup, nil
}

// GetChangedFiles reads the git diff to find what files Claude Code modified.
func GetChangedFiles(repoDir string) ([]FileChange, error) {
	// Get list of modified/added files
	cmd := exec.Command("git", "status", "--porcelain")
	cmd.Dir = repoDir

	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("git status failed: %w", err)
	}

	var changes []FileChange
	scanner := bufio.NewScanner(bytes.NewReader(output))

	for scanner.Scan() {
		line := scanner.Text()
		if len(line) < 3 {
			continue
		}

		status := line[:2]
		filePath := strings.TrimSpace(line[3:])

		var changeType string
		switch {
		case strings.Contains(status, "A") || strings.Contains(status, "?"):
			changeType = "create"
		case strings.Contains(status, "D"):
			changeType = "delete"
		case strings.Contains(status, "M"):
			changeType = "modify"
		default:
			changeType = "modify"
		}

		// Read file content (unless deleted)
		var content string
		if changeType != "delete" {
			fullPath := filepath.Join(repoDir, filePath)
			data, err := os.ReadFile(fullPath)
			if err != nil {
				return nil, fmt.Errorf("failed to read %s: %w", filePath, err)
			}
			content = string(data)
		}

		changes = append(changes, FileChange{
			Path:       filePath,
			Content:    content,
			ChangeType: changeType,
		})
	}

	return changes, scanner.Err()
}
